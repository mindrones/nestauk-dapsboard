import * as _ from 'lamb';
import {containsOneOf, mergeObj} from '@svizzle/utils';

/* types */

const typeKey = '__type';
const shapeKey = '__shape';

export const _type = str => ({[typeKey]: str});
export const _shape = str => ({[shapeKey]: str});
export const is_shape = id => _.pipe([_.getKey(shapeKey), _.is(id)]);
export const is_type = id => _.pipe([_.getKey(typeKey), _.is(id)]);
export const isTyped = _.anyOf([_.hasKey(typeKey), _.hasKey(shapeKey)]);
export const notTyped = _.not(isTyped);

// native

export const boolean = _type('boolean');
export const float = _type('float');
export const integer = _type('integer');
export const string = _type('string');

// array
export const array = _shape('array');
export const arrayOf = mergeObj(array);

// enums
export const enums = _shape('enums');
export const enumsOf = _.pipe([
	_.list,
	values => ({values, ...enums})
]);
const is_enums = is_shape('enums');

// object
export const object = _shape('object');
export const objectOf = mergeObj(object);
export const emptyObject = objectOf({});

// union
export const union = _shape('union');
export const unionOf = _.pipe([
	_.list,
	types => ({types, ...union})
]);

// xor
export const xor = _shape('xor');
export const xorOf = mergeObj(xor);

// number
export const number = unionOf(integer, float);

// extent
export const extent = {
	..._shape('extent'),
	min: number,
	max:  number,
};

// record
export const record = _shape('record');
export const recordLike = ({keys, values}) => ({
	...record,
	values,
	_keys: keys && is_enums(keys) || string,
});

export const constant = ({type, shape, value}) => ({
	..._shape('constant'),
	value,
	...type ? {[typeKey]: type} : {},
	...shape ? {[shapeKey]: shape} : {},
});

// numString (parses as a number)

export const numString = _shape('numString');
export const numStringOf = stringValue => ({
	...numString,
	stringValue,
});

// numberInExtent

export const numberWithinExtent = {
	..._shape('numberWithinExtent'),
	...number,
	min: number,
	max:  number,
};
export const numberWithin = ([min, max]) => ({
	...numberWithinExtent,
	min,
	max,
});

/* utils */

const isLabelOf = _.pipe([
	_.list,
	_.pluck(typeKey),
	_.apply(containsOneOf)
]);

const isNumberLabel = isLabelOf(integer, float);

export const numberOrString = fieldType =>
	_type(isNumberLabel(fieldType) ? fieldType : 'string');

export const objectifyValues = _.mapValuesWith(_.when(notTyped, objectOf));
