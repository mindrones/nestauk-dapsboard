import * as _ from 'lamb';
import {mergeObj} from '@svizzle/utils';

import aggsIdByFieldType from 'app/elasticsearch/config/aggsIdByFieldType';
import {
	_type,
	arrayOf,
	boolean,
	emptyObject,
	enumsOf,
	extent,
	float,
	integer,
	objectifyValues,
	numberOrString,
	object,
	objectOf,
	recordLike,
	string,
	unionOf,
	xorOf,
} from 'app/elasticsearch/types/genericTypes';
import {
	existence,
	script,
	genericInterval,
	calendarInterval,
	fixedInterval
} from 'app/elasticsearch/types/esTypes/params';

// conditions

const optional = mergeObj({__optional: true});

/* params */

const baseParamsFor = fieldType => ({
	field: string,
	missing: optional(numberOrString(fieldType))
});

const sortOptions = objectOf({
	_key: optional(enumsOf('asc', 'desc')),
	_count: optional(enumsOf('asc', 'desc')),
});

const staticShapeParamsByMetricAgg = {
	scripted_metric: {
		init_script: script,
		map_script: script,
		combine_script: script,
		reduce_script: script,
	},
	top_hits: {
		from: optional(integer),
		size: optional(integer),
		sort: optional(sortOptions),
		_source: unionOf(string, arrayOf(string))
	},
};

const makeShapeParamsByMetricAgg = fieldType => ({
	avg: baseParamsFor(fieldType),
	boxplot: {
		...baseParamsFor(fieldType),
		compression: optional(integer),
	},
	cardinality: {
		...baseParamsFor(fieldType),
		precision_threshold: optional(integer),
	},
	extended_stats: {
		...baseParamsFor(fieldType),
		sigma: optional(float),
	},
	geo_bounds: {
		...baseParamsFor(fieldType),
		wrap_longitude: optional(boolean),
	},
	geo_centroid: baseParamsFor(fieldType),
	max: baseParamsFor(fieldType),
	median_absolute_deviation: {
		...baseParamsFor(fieldType),
		compression: optional(integer),
	},
	min: baseParamsFor(fieldType),
	percentile_ranks: {
		...baseParamsFor(fieldType),
		values: arrayOf(float),
		keyed: optional(boolean),
		hdr: optional(objectOf({
			number_of_significant_value_digits: integer
		}))
	},
	percentiles: {
		...baseParamsFor(fieldType),
		percents: optional(arrayOf(float)),
		keyed: optional(boolean),
		tdigest: optional(objectOf({
			compression: integer
		})),
		hdr: optional(objectOf({
			number_of_significant_value_digits: integer
		})),
	},
	stats: baseParamsFor(fieldType),
	string_stats: {
		...baseParamsFor(fieldType),
		show_distribution: optional(boolean)
	},
	sum: baseParamsFor(fieldType),
	t_test: {
		a: objectOf({
			...baseParamsFor(fieldType),
			filter: optional(object)
		}),
		b: objectOf({
			...baseParamsFor(fieldType),
			filter: optional(object)
		}),
		type: enumsOf('paired', 'homoscedastic', 'heteroscedastic')
	},
	top_metrics: {
		metric: unionOf(
			baseParamsFor(fieldType),
			arrayOf(objectOf(baseParamsFor(fieldType)))
		),
		sort: sortOptions,
		size: optional(integer)
	},
	value_count: baseParamsFor(fieldType),
	weighted_avg: {
		value: baseParamsFor(fieldType),
		weight: baseParamsFor(fieldType),
		format: optional(object),
		value_type: optional(object)
	},
});

const staticShapeParamsByBucketingAgg = {
	adjacency_matrix: {
		filters: recordLike({
			type: recordLike({
				keys: enumsOf('field'),
				values: arrayOf(string)
			})
		}),
		separator: string
	},
	children: {
		type: string
	},
	filter: {
		filter: object
	},
	filters: {
		other_bucket: optional(boolean),
		other_bucket_key: optional(string),
		filters: arrayOf(object)
	},
	geohash_grid: {
		field: enumsOf('field'),
		precision: optional(integer),
		size: optional(integer),
		shard_size: optional(integer)
	},
	global: emptyObject,
	nested: {
		path: string
	},
	reverse_nested: {
		path: optional(string)
	},
	sampler: {
		shard_size: optional(integer)
	},
};

const makeShapeParamsByBucketingAgg = fieldType => ({
	auto_date_histogram: {
		...baseParamsFor(fieldType),
		buckets: optional(integer),
		format: optional(string),
		time_zone: optional(string),
		minimum_inteval: optional(string),
	},
	composite: {
		sources: recordLike({
			type: objectOf({
				...baseParamsFor(fieldType),
				size: integer,
				order: optional(sortOptions),
			})
		}),
		size: optional(integer),
		after: object // FIXME seems optional in the UI?
	},
	date_histogram: {
		...baseParamsFor(fieldType),
		__intervals: xorOf({
			interval: genericInterval,
			calendar_interval: calendarInterval,
			fixed_interval: fixedInterval
		}),
		time_zone: string,
		order: optional(sortOptions),
		min_doc_count: optional(integer)
	},
	date_range: {
		...baseParamsFor(fieldType),
		format: string,
		ranges: arrayOf(objectOf({
			key: optional(string),
			from: optional(string),
			to: optional(string),
		})),
		keyed: optional(boolean)
	},
	diversified_sampler: {
		...baseParamsFor(fieldType),
		execution_hint: optional(enumsOf('map', 'global_ordinals', 'bytes_hash')),
		max_docs_per_value: optional(integer),
		shard_size: optional(integer)
	},
	geo_distance: {
		...baseParamsFor(fieldType),
		origin: string,
		unit: enumsOf('m', 'mi', 'in', 'yd', 'km', 'cm', 'mm'),
		ranges: arrayOf(object),
		keyed: optional(boolean),
		distance_type: enumsOf('arc', 'plane')
	},
	histogram: {
		...baseParamsFor(fieldType),
		interval: _type(fieldType),
		offset: optional(_type(fieldType)),
		min_doc_count: optional(integer),
		keyed: optional(boolean),
		order: optional(sortOptions),
		extended_bounds: optional(extent)
	},
	ip_range: baseParamsFor(fieldType),
	missing: baseParamsFor(fieldType),
	range: {
		...baseParamsFor(fieldType),
		ranges: arrayOf(object)
	},
	rare_terms: {
		...baseParamsFor(fieldType),
		max_doc_count: optional(integer),
		precision: optional(float),
		include: optional(arrayOf(string)),
		exclude: optional(arrayOf(string)),
	},
	significant_terms: {
		...baseParamsFor(fieldType),
		min_doc_count: optional(integer),
		background_filter: optional(
			objectOf({
				term: objectOf({
					content: string
				})
			})
		),
		jlh: optional(emptyObject),
		mutual_information: optional(
			objectOf({
				include_negatives: optional(boolean),
				background_is_superset: optional(boolean)
			})
		),
		chi_square: optional(existence),
		gnd: optional(existence),
		percentage: optional(existence),
	},
	significant_text: {
		...baseParamsFor(fieldType),
		filter_duplicate_text: optional(boolean),
		background_filter: optional(objectOf({
			term: objectOf({
				content: string
			})
		})),
		source_fields: optional(arrayOf(string))
	},
	terms: {
		...baseParamsFor(fieldType),
		collect_mode: enumsOf('depth_first', 'breadth_first'),
		execution_hint: enumsOf('global_ordinals', 'map'),
		order: optional(sortOptions),
		size: integer,
	},
});

/*
const paramsShapeByMatrixAgg = {
	matrix_stats: {
		fields: {__array: 'fields'},
		missing: [

			,
			'undefined'
		]
	}
};
*/

const makeAggParamShapeByAggId = fieldType => objectifyValues({
	...staticShapeParamsByMetricAgg,
	...makeShapeParamsByMetricAgg(fieldType),
	...staticShapeParamsByBucketingAgg,
	...makeShapeParamsByBucketingAgg(fieldType),
	// ...paramsShapeByMatrixAgg
});

export default _.mapValues(
	aggsIdByFieldType,
	(...[,fieldType]) => makeAggParamShapeByAggId(fieldType)
)
