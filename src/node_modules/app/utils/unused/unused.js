import * as _ from 'lamb';

import {applyFnMap} from '@svizzle/utils';

import {getESType} from 'app/elasticsearch/utils/aggFields';
import {indexById, descentReducer} from 'app/utils/generic';
import {getSchema} from 'app/utils/specs';

const createPropDefs = _.mapWith(([field, EStype]) => `	${field}: ${EStype};`);

const createTypeDef = ([datasetId, fieldEStypePairs]) => `export type ${datasetId} = {
	${createPropDefs(fieldEStypePairs).join('\n')}
};
`;

export const generateTypingsForAll = _.pipe([
	indexById,
	_.mapValuesWith(_.pipe([
		getSchema,
		_.mapValuesWith(getESType),
		_.pairs,
	])),
	_.pairs,
	_.mapWith(createTypeDef)
]);

/* URL parsing */

const transformAggregation = applyFnMap({
	name: _.getAt(0),
	aggregation: _.pipe([
		_.getAt(1),
		_.skip(['aggs']),
		_.pairs,
		_.getPath('0.0'),
	]),
	field: _.pipe([
		_.getAt(1),
		_.skip(['aggs']),
		_.pairs,
		_.getPath('0.1'),
		_.getKey('field')
	]),
	params: _.pipe([
		_.getAt(1),
		_.skip(['aggs']),
		_.pairs,
		_.getPath('0.1'),
		_.skip(['field'])
	]),
	subaggs: _.pipe([
		_.getAt(1),
		_.casus(
			_.hasKey('aggs'),
			_.pipe([
				_.pick(['aggs']),
				_.pairs,
				_.getPath('0.1'),
				_.keys,
			])
		)
	]),
});

const hasSubAggs = _.pipe([
	_.getAt(1),
	_.hasKey('aggs'),
]);

const getSubAggs = _.pipe([
	_.getPath('1.aggs'),
	_.pairs,
])

const transformAndAppendAggs = (total, pair) => [
	...total,
	transformAggregation(pair)
];

export const makeIntermediateObj = applyFnMap({
	size: _.getPath('size'),
	aggs: _.pipe([
		_.getPath('aggs'),
		_.pairs,
		_.getAt(0),
		descentReducer(hasSubAggs, getSubAggs)(transformAndAppendAggs, []),
	])
});
